/*答案是先归并在排序，引入第三方数组，思路大致差不多*/
#include<iostream>
#include<vector>

using namespace std;

class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) 
	{
		double n = 0;
		int length1 = nums1.size();
		static vector<int>::iterator p;
		for (int i = 0; i < nums2.size(); i++)
		{
			bool flags = false;
			for (p = nums1.begin(); p != nums1.end(); p++)
			{
				if (nums2[i] <= *p)
				{
					nums1.insert(p, nums2[i]);
					length1++;
					flags = true;
					break;
				}
				//第一次错误，查到后没有跳出这个循环，直接导致和想要的结果不同
				//修改加break
			}
			//第二次错误,要考虑多种情况，比如说比较的第二个数组是否比第一个大
			//先采用长度判断的方法，发现把简单问题复杂化了，引入是否插入标志后解决
			if (flags == false)
			{
				nums1.push_back(nums2[i]);
				length1++;
			}
		}
		if (nums1.size() % 2 == 0)
			n = (double)(nums1[nums1.size() / 2 - 1] + nums1[nums1.size() / 2]) / 2;
		else
			n = (double)nums1[nums1.size()/2];
		return n;
	}
};


int main()
{
	Solution a;
	double t;
	vector<int> array1 = { 1,3 };
	vector<int> array2 = { 2,7 };
	a.findMedianSortedArrays(array1, array2);

	system("pause");
	return 0;
}